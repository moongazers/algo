<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
        <title>Longest Harmonious Subsequence</title>
    </head>
    <body>
        <pre>
        We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.

        Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.

        Example 1:
        Input: [1,3,2,2,5,2,3,7]
        Output: 5
        Explanation: The longest harmonious subsequence is [3,2,2,2,3].
        Note: The length of the input array will not exceed 20,000.
        </pre>
        
        <script>
            /**
            * @param {number[]} nums
            * @return {number}
            */
            var findLHS = function(nums) {
                // first thought: iterate the obj and check the diff of other elems to cur elem
                // O(n^2), not worth
                // use map, and check adjacent keys
                var map = {};
                var max = 0;
                for (var i = 0; i < nums.length; i++) {
                    if (map[nums[i]]) {
                        map[nums[i]] += 1;
                    } else {
                        map[nums[i]] = 1;
                    }
                }
                console.log(map);

                for (var key in map) {
                    var cur = 0;
                    if (map[parseInt(key)+1]) {  //MISTAKE 1:  key(if it's 1) + 1 => 11
                        cur = map[key] + map[parseInt(key)+1];
                    } 
                    max = Math.max(max, cur);
                }
                return max;
            };

            var nums = [1,3,2,2,5,2,3,7];
            var result = findLHS(nums);
            console.log(result);
        </script>
    </body>
</html>




<!--var node = head;
                var previous = null;

                while(node) {
                    // save next or you lose it!!!
                    var save = node.next;
                    // reverse pointer
                    node.next = previous;
                    // increment previous to current node
                    previous = node;
                    // increment node to next node or null at end of list
                    node = save;
                }
                return previous;   // Change the list head !!!-->